{
  "address": "0x66Af21F227d37D411fD63173D13c74782721ABf1",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "airdropId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "ipfs",
          "type": "string"
        }
      ],
      "name": "NewAirdrop",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "airdropId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Redemption",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "airdropId",
          "type": "uint256"
        }
      ],
      "name": "StoppedAirdrop",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "airdrops",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "merkleRoot",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_merkleRoot",
          "type": "bytes32"
        },
        {
          "internalType": "contract IERC20",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_ipfs",
          "type": "string"
        }
      ],
      "name": "createAirdrop",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_airdropId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_claimedAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "redeem",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "redeemed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_airdropId",
          "type": "uint256"
        }
      ],
      "name": "stopAirdrop",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_airdropId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_claimedAmount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "_merkleProof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifyClaim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "valid",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x340ae11ac86eca768cd500bc01abba621aee6e24714e193fdb1115b4a56536c7",
  "receipt": {
    "to": null,
    "from": "0xF50E77f2A2B6138D16c6c7511562E5C33c4B15A3",
    "contractAddress": "0x66Af21F227d37D411fD63173D13c74782721ABf1",
    "transactionIndex": 0,
    "gasUsed": "687383",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6bfc5e2470ec72a14a22456459de0cec5e66da1e45017542ee02205797fd51ac",
    "transactionHash": "0x340ae11ac86eca768cd500bc01abba621aee6e24714e193fdb1115b4a56536c7",
    "logs": [],
    "blockNumber": 24522679,
    "cumulativeGasUsed": "687383",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ede30b875c8a2c6e804314c58309278f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"airdropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"NewAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"airdropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redemption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"airdropId\",\"type\":\"uint256\"}],\"name\":\"StoppedAirdrop\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"airdrops\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_ipfs\",\"type\":\"string\"}],\"name\":\"createAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_airdropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_airdropId\",\"type\":\"uint256\"}],\"name\":\"stopAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_airdropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"...\",\"kind\":\"dev\",\"methods\":{\"verifyClaim(uint256,uint256,bytes32[])\":{\"params\":{\"_airdropId\":\"The id of the airdrop.\",\"_claimedAmount\":\"The amount being claimed.\",\"_merkleProof\":\"The merkle proof for the claim, sorted from the leaf to the root of the tree.\"}}},\"title\":\"Cocodrop\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"verifyClaim(uint256,uint256,bytes32[])\":{\"notice\":\"Verifies a claim.\"}},\"notice\":\"...\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/Cocodrop.sol\":\"Cocodrop\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\\n     * consuming from one or the other at each step according to the instructions given by\\n     * `proofFlags`.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value for the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            return hashes[totalHashes - 1];\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x596ed72a251d391b814a4aa19d7acb02ebdcc92ba27d3fff74a6f0c158b12ab7\",\"license\":\"MIT\"},\"src/Cocodrop.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/**\\n * @authors: [@greenlucid, @shotaronowhere, @jaybuidl]\\n * @reviewers: []\\n * @auditors: []\\n * @bounties: []\\n * @deployments: []\\n */\\n\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\n/**\\n * @title Cocodrop\\n * @notice ...\\n * @dev ...\\n */\\ncontract Cocodrop {\\n\\n  struct Airdrop {\\n    address owner;\\n    bytes32 merkleRoot;\\n    IERC20 token;\\n    uint256 amount;\\n  }\\n\\n  event NewAirdrop(uint256 indexed airdropId, bytes32 merkleRoot, IERC20 token, uint256 amount, string ipfs);\\n  event StoppedAirdrop(uint256 indexed airdropId);\\n  event Redemption(uint256 indexed airdropId, uint256 amount);\\n\\n  Airdrop[] public airdrops;\\n  mapping(uint256 => mapping(address => bool)) public redeemed;\\n\\n\\n  function createAirdrop(bytes32 _merkleRoot, IERC20 _token, uint256 _amount, string calldata _ipfs) external {\\n    require(_token.transferFrom(msg.sender, address(this), _amount), \\\"Transfer failed\\\");\\n    airdrops.push(Airdrop({\\n      owner: msg.sender,\\n      merkleRoot: _merkleRoot,\\n      token: _token,\\n      amount: _amount\\n    }));\\n    emit NewAirdrop(airdrops.length - 1, _merkleRoot, _token, _amount, _ipfs);\\n  }\\n\\n  function stopAirdrop(uint256 _airdropId) external {\\n    Airdrop storage airdrop = airdrops[_airdropId];    \\n    // check\\n    require(msg.sender == airdrop.owner, \\\"Owner only\\\");\\n    require(airdrop.amount > 0, \\\"Already stopped\\\");    \\n    // effects\\n    uint256 amountToSend = airdrop.amount;\\n    airdrop.amount = 0;\\n    // interact\\n    require(airdrop.token.transfer(msg.sender, amountToSend), \\\"Transfer failed\\\");\\n    emit StoppedAirdrop(_airdropId);\\n  }\\n\\n  function redeem(uint256 _airdropId, uint256 _claimedAmount, bytes32[] memory _merkleProof) public {\\n    uint256 airdropBalance = airdrops[_airdropId].amount;\\n    // check\\n    require(_claimedAmount <= airdropBalance, \\\"Insufficient airdrop balance\\\");\\n    require(!redeemed[_airdropId][msg.sender], \\\"Already redeemed\\\");\\n    require(verifyClaim(_airdropId, _claimedAmount, _merkleProof), \\\"Invalid redemption\\\");\\n    // effects\\n    redeemed[_airdropId][msg.sender] = true;\\n    airdrops[_airdropId].amount -= _claimedAmount;\\n    // interact\\n    airdrops[_airdropId].token.transfer(msg.sender, _claimedAmount);\\n    emit Redemption(_airdropId, _claimedAmount);\\n  }\\n\\n    /**\\n     * @notice Verifies a claim.\\n     * @param _claimedAmount The amount being claimed.\\n     * @param _merkleProof The merkle proof for the claim, sorted from the leaf to the root of the tree.\\n     * @param _airdropId The id of the airdrop.\\n     */\\n    function verifyClaim(\\n        uint256 _airdropId,\\n        uint256 _claimedAmount,\\n        bytes32[] memory _merkleProof\\n    )\\n        public\\n        view\\n        returns (bool valid)\\n    {\\n      // less gas efficient than assembly, but this suffices for v1\\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _claimedAmount));\\n      return MerkleProof.verify(_merkleProof, airdrops[_airdropId].merkleRoot, leaf);\\n    }\\n}\\n\",\"keccak256\":\"0x224007601198346969e72ed3dfbb9a04a468711b9f05a10b68e521248b2cecd1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610b79806100206000396000f3fe608060405234801561001057600080fd5b50600436106100625760003560e01c80635ddb08451461006757806360db5082146100aa5780637306239f146100f25780637efcf12814610107578063839044851461011a578063b97bff1a1461012d575b600080fd5b6100956100753660046108b2565b600160209081526000928352604080842090915290825290205460ff1681565b60405190151581526020015b60405180910390f35b6100bd6100b83660046108e2565b610140565b6040516100a194939291906001600160a01b039485168152602081019390935292166040820152606081019190915260800190565b6101056101003660046108fb565b610188565b005b6101056101153660046108e2565b61038c565b6100956101283660046109a7565b61052f565b61010561013b3660046109a7565b6105a9565b6000818154811061015057600080fd5b600091825260209091206004909102018054600182015460028301546003909301546001600160a01b03928316945090929091169084565b6040516323b872dd60e01b8152336004820152306024820152604481018490526001600160a01b038516906323b872dd906064016020604051808303816000875af11580156101db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ff9190610a7a565b6102425760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b60448201526064015b60405180910390fd5b60408051608081018252338152602081018781526001600160a01b03878116938301938452606083018781526000805460018181018355828052955160049091027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563810180549286166001600160a01b031993841617905594517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56486015595517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5658501805491909416961695909517909155517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5669091015590546103469190610ab2565b7fa07dc081e463c1b1f74a9fbaeb0d45590e0121e6dd8a976da3765021ba40c797868686868660405161037d959493929190610ac5565b60405180910390a25050505050565b60008082815481106103a0576103a0610b14565b6000918252602090912060049091020180549091506001600160a01b031633146103f95760405162461bcd60e51b815260206004820152600a6024820152694f776e6572206f6e6c7960b01b6044820152606401610239565b600081600301541161043f5760405162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e481cdd1bdc1c1959608a1b6044820152606401610239565b6003810180546000909155600282015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb906044016020604051808303816000875af115801561049d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c19190610a7a565b6104ff5760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606401610239565b60405183907f4f403e266a39854b8e8550830afc0d95e2865e035d4ee613860d9ba38322e93e90600090a2505050565b6040516bffffffffffffffffffffffff193360601b1660208201526034810183905260009081906054016040516020818303038152906040528051906020012090506105a0836000878154811061058857610588610b14565b90600052602060002090600402016001015483610803565b95945050505050565b60008084815481106105bd576105bd610b14565b9060005260206000209060040201600301549050808311156106215760405162461bcd60e51b815260206004820152601c60248201527f496e73756666696369656e742061697264726f702062616c616e6365000000006044820152606401610239565b600084815260016020908152604080832033845290915290205460ff161561067e5760405162461bcd60e51b815260206004820152601060248201526f105b1c9958591e481c995919595b595960821b6044820152606401610239565b61068984848461052f565b6106ca5760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b2103932b232b6b83a34b7b760711b6044820152606401610239565b60008481526001602081815260408084203385529091528220805460ff1916909117905580548491908690811061070357610703610b14565b906000526020600020906004020160030160008282546107239190610ab2565b9091555050600080548590811061073c5761073c610b14565b600091825260209091206004918202016002015460405163a9059cbb60e01b81523392810192909252602482018590526001600160a01b03169063a9059cbb906044016020604051808303816000875af115801561079e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c29190610a7a565b50837fba7975764e321f07896c9c9852213d675ea0ab36b67e22a7e6d762b0fddd30d9846040516107f591815260200190565b60405180910390a250505050565b6000826108108584610819565b14949350505050565b600081815b845181101561085e5761084a8286838151811061083d5761083d610b14565b6020026020010151610868565b91508061085681610b2a565b91505061081e565b5090505b92915050565b6000818310610884576000828152602084905260409020610893565b60008381526020839052604090205b9392505050565b6001600160a01b03811681146108af57600080fd5b50565b600080604083850312156108c557600080fd5b8235915060208301356108d78161089a565b809150509250929050565b6000602082840312156108f457600080fd5b5035919050565b60008060008060006080868803121561091357600080fd5b8535945060208601356109258161089a565b935060408601359250606086013567ffffffffffffffff8082111561094957600080fd5b818801915088601f83011261095d57600080fd5b81358181111561096c57600080fd5b89602082850101111561097e57600080fd5b9699959850939650602001949392505050565b634e487b7160e01b600052604160045260246000fd5b6000806000606084860312156109bc57600080fd5b833592506020808501359250604085013567ffffffffffffffff808211156109e357600080fd5b818701915087601f8301126109f757600080fd5b813581811115610a0957610a09610991565b8060051b604051601f19603f83011681018181108582111715610a2e57610a2e610991565b60405291825284820192508381018501918a831115610a4c57600080fd5b938501935b82851015610a6a57843584529385019392850192610a51565b8096505050505050509250925092565b600060208284031215610a8c57600080fd5b8151801515811461089357600080fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561086257610862610a9c565b8581526001600160a01b0385166020820152604081018490526080606082018190528101829052818360a0830137600081830160a090810191909152601f909201601f19160101949350505050565b634e487b7160e01b600052603260045260246000fd5b600060018201610b3c57610b3c610a9c565b506001019056fea264697066735822122036481a9ad4241297e5b7d1d5cf1b7ab19cae2f9a940f2ce63a9a317c89579ca364736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100625760003560e01c80635ddb08451461006757806360db5082146100aa5780637306239f146100f25780637efcf12814610107578063839044851461011a578063b97bff1a1461012d575b600080fd5b6100956100753660046108b2565b600160209081526000928352604080842090915290825290205460ff1681565b60405190151581526020015b60405180910390f35b6100bd6100b83660046108e2565b610140565b6040516100a194939291906001600160a01b039485168152602081019390935292166040820152606081019190915260800190565b6101056101003660046108fb565b610188565b005b6101056101153660046108e2565b61038c565b6100956101283660046109a7565b61052f565b61010561013b3660046109a7565b6105a9565b6000818154811061015057600080fd5b600091825260209091206004909102018054600182015460028301546003909301546001600160a01b03928316945090929091169084565b6040516323b872dd60e01b8152336004820152306024820152604481018490526001600160a01b038516906323b872dd906064016020604051808303816000875af11580156101db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ff9190610a7a565b6102425760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b60448201526064015b60405180910390fd5b60408051608081018252338152602081018781526001600160a01b03878116938301938452606083018781526000805460018181018355828052955160049091027f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563810180549286166001600160a01b031993841617905594517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56486015595517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5658501805491909416961695909517909155517f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e5669091015590546103469190610ab2565b7fa07dc081e463c1b1f74a9fbaeb0d45590e0121e6dd8a976da3765021ba40c797868686868660405161037d959493929190610ac5565b60405180910390a25050505050565b60008082815481106103a0576103a0610b14565b6000918252602090912060049091020180549091506001600160a01b031633146103f95760405162461bcd60e51b815260206004820152600a6024820152694f776e6572206f6e6c7960b01b6044820152606401610239565b600081600301541161043f5760405162461bcd60e51b815260206004820152600f60248201526e105b1c9958591e481cdd1bdc1c1959608a1b6044820152606401610239565b6003810180546000909155600282015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb906044016020604051808303816000875af115801561049d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c19190610a7a565b6104ff5760405162461bcd60e51b815260206004820152600f60248201526e151c985b9cd9995c8819985a5b1959608a1b6044820152606401610239565b60405183907f4f403e266a39854b8e8550830afc0d95e2865e035d4ee613860d9ba38322e93e90600090a2505050565b6040516bffffffffffffffffffffffff193360601b1660208201526034810183905260009081906054016040516020818303038152906040528051906020012090506105a0836000878154811061058857610588610b14565b90600052602060002090600402016001015483610803565b95945050505050565b60008084815481106105bd576105bd610b14565b9060005260206000209060040201600301549050808311156106215760405162461bcd60e51b815260206004820152601c60248201527f496e73756666696369656e742061697264726f702062616c616e6365000000006044820152606401610239565b600084815260016020908152604080832033845290915290205460ff161561067e5760405162461bcd60e51b815260206004820152601060248201526f105b1c9958591e481c995919595b595960821b6044820152606401610239565b61068984848461052f565b6106ca5760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b2103932b232b6b83a34b7b760711b6044820152606401610239565b60008481526001602081815260408084203385529091528220805460ff1916909117905580548491908690811061070357610703610b14565b906000526020600020906004020160030160008282546107239190610ab2565b9091555050600080548590811061073c5761073c610b14565b600091825260209091206004918202016002015460405163a9059cbb60e01b81523392810192909252602482018590526001600160a01b03169063a9059cbb906044016020604051808303816000875af115801561079e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c29190610a7a565b50837fba7975764e321f07896c9c9852213d675ea0ab36b67e22a7e6d762b0fddd30d9846040516107f591815260200190565b60405180910390a250505050565b6000826108108584610819565b14949350505050565b600081815b845181101561085e5761084a8286838151811061083d5761083d610b14565b6020026020010151610868565b91508061085681610b2a565b91505061081e565b5090505b92915050565b6000818310610884576000828152602084905260409020610893565b60008381526020839052604090205b9392505050565b6001600160a01b03811681146108af57600080fd5b50565b600080604083850312156108c557600080fd5b8235915060208301356108d78161089a565b809150509250929050565b6000602082840312156108f457600080fd5b5035919050565b60008060008060006080868803121561091357600080fd5b8535945060208601356109258161089a565b935060408601359250606086013567ffffffffffffffff8082111561094957600080fd5b818801915088601f83011261095d57600080fd5b81358181111561096c57600080fd5b89602082850101111561097e57600080fd5b9699959850939650602001949392505050565b634e487b7160e01b600052604160045260246000fd5b6000806000606084860312156109bc57600080fd5b833592506020808501359250604085013567ffffffffffffffff808211156109e357600080fd5b818701915087601f8301126109f757600080fd5b813581811115610a0957610a09610991565b8060051b604051601f19603f83011681018181108582111715610a2e57610a2e610991565b60405291825284820192508381018501918a831115610a4c57600080fd5b938501935b82851015610a6a57843584529385019392850192610a51565b8096505050505050509250925092565b600060208284031215610a8c57600080fd5b8151801515811461089357600080fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561086257610862610a9c565b8581526001600160a01b0385166020820152604081018490526080606082018190528101829052818360a0830137600081830160a090810191909152601f909201601f19160101949350505050565b634e487b7160e01b600052603260045260246000fd5b600060018201610b3c57610b3c610a9c565b506001019056fea264697066735822122036481a9ad4241297e5b7d1d5cf1b7ab19cae2f9a940f2ce63a9a317c89579ca364736f6c63430008110033",
  "devdoc": {
    "details": "...",
    "kind": "dev",
    "methods": {
      "verifyClaim(uint256,uint256,bytes32[])": {
        "params": {
          "_airdropId": "The id of the airdrop.",
          "_claimedAmount": "The amount being claimed.",
          "_merkleProof": "The merkle proof for the claim, sorted from the leaf to the root of the tree."
        }
      }
    },
    "title": "Cocodrop",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "verifyClaim(uint256,uint256,bytes32[])": {
        "notice": "Verifies a claim."
      }
    },
    "notice": "...",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 647,
        "contract": "src/Cocodrop.sol:Cocodrop",
        "label": "airdrops",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_struct(Airdrop)620_storage)dyn_storage"
      },
      {
        "astId": 653,
        "contract": "src/Cocodrop.sol:Cocodrop",
        "label": "redeemed",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_bool))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(Airdrop)620_storage)dyn_storage": {
        "base": "t_struct(Airdrop)620_storage",
        "encoding": "dynamic_array",
        "label": "struct Cocodrop.Airdrop[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IERC20)77": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_struct(Airdrop)620_storage": {
        "encoding": "inplace",
        "label": "struct Cocodrop.Airdrop",
        "members": [
          {
            "astId": 612,
            "contract": "src/Cocodrop.sol:Cocodrop",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 614,
            "contract": "src/Cocodrop.sol:Cocodrop",
            "label": "merkleRoot",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          },
          {
            "astId": 617,
            "contract": "src/Cocodrop.sol:Cocodrop",
            "label": "token",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(IERC20)77"
          },
          {
            "astId": 619,
            "contract": "src/Cocodrop.sol:Cocodrop",
            "label": "amount",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}